#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GMQ710 - PROJET FINAL : Pipeline 3D avec zone personnalisable
Solution : B√¢timents en GeoJSON + V√©g√©tation en GeoPackage (points)
"""

import os
import json
import numpy as np
import geopandas as gpd
import rasterio
from rasterio.features import rasterize
from rasterio.windows import Window
from shapely.geometry import Point, Polygon, box
from pyproj import Transformer

# ------------------------------------------------------------------------------
# 1. CONFIGURATION - √Ä MODIFIER SELON VOS BESOINS
# ------------------------------------------------------------------------------
BASE_PATH = r"C:\Users\QAREK MBENGMO\Desktop\GMQ710\TD2\Donnees sources"

# Fichiers d'entr√©e
DSM_FILE = "dsm_1m_utm19_w_22_102.tif"
DTM_FILE = "dtm_1m_utm19_w_22_102.tif"
OSM_FILE = "buildings_sherbrooke_osm.geojson"

# Fichiers de sortie
BUILDINGS_OUTPUT = "batiments_3d_sherbrooke.geojson"
VEGETATION_OUTPUT = "vegetation_points_sherbrooke.gpkg"

# Param√®tres techniques
TARGET_CRS_EPSG = 26919  # UTM 19N
TARGET_CRS = f'EPSG:{TARGET_CRS_EPSG}'
WGS84_CRS = 'EPSG:4326'  # Latitude/Longitude

MIN_HEIGHT_BLD = 3.0      # Hauteur minimale d'un b√¢timent (m)
MIN_HEIGHT_TREE = 2.5     # Hauteur minimale de v√©g√©tation (m)

# ------------------------------------------------------------------------------
# 2. D√âFINITION DE LA ZONE D'√âTUDE - MODIFIEZ ICI !
# ------------------------------------------------------------------------------
# Format : longitude,latitude (WGS84)
# Exemple : [-71.932847,45.381367],[-71.920931,45.381307],[-71.932892,45.375654],[-71.921444,45.376154]

# D√©finir vos points au format longitude,latitude
WGS84_COORDS = [
    [-71.932847, 45.381367],  # Point 1
    [-71.920931, 45.381307],  # Point 2  
    [-71.924029, 45.375547],  # Point 3
    [-71.921444, 45.376154]   # Point 4
]

BUFFER_DISTANCE = 20  # Buffer en m√®tres (recommand√©: 20)

# ------------------------------------------------------------------------------
# 3. FONCTIONS PRINCIPALES
# ------------------------------------------------------------------------------

def get_raster_bounds(raster_path):
    """R√©cup√®re les limites d'un raster"""
    with rasterio.open(raster_path) as src:
        return src.bounds, src.crs

def wgs84_to_utm(coords_wgs84, target_crs_epsg=26919):
    """Convertit des coordonn√©es WGS84 (lon,lat) en UTM"""
    transformer = Transformer.from_crs(WGS84_CRS, f'EPSG:{target_crs_epsg}', always_xy=True)
    
    # Convertir chaque point
    coords_utm = []
    for lon, lat in coords_wgs84:
        x, y = transformer.transform(lon, lat)
        coords_utm.append((x, y))
    
    return coords_utm

def create_utm_zone_from_points(points_utm):
    """Cr√©e une zone UTM rectangulaire √† partir de points"""
    if not points_utm:
        return None
    
    # Extraire tous les x et y
    x_coords = [pt[0] for pt in points_utm]
    y_coords = [pt[1] for pt in points_utm]
    
    # Cr√©er une bo√Æte englobante
    xmin, xmax = min(x_coords), max(x_coords)
    ymin, ymax = min(y_coords), max(y_coords)
    
    return (xmin, ymin, xmax, ymax)

def validate_and_adjust_zone(zone_coords, raster_bounds):
    """Valide et ajuste la zone aux limites du raster"""
    xmin, ymin, xmax, ymax = zone_coords
    
    # V√©rifier l'ordre
    if xmin >= xmax:
        xmin, xmax = xmax, xmin
    if ymin >= ymax:
        ymin, ymax = ymax, ymin
    
    # Ajuster aux limites
    xmin = max(raster_bounds.left, xmin)
    ymin = max(raster_bounds.bottom, ymin)
    xmax = min(raster_bounds.right, xmax)
    ymax = min(raster_bounds.top, ymax)
    
    return (xmin, ymin, xmax, ymax)

def crop_raster_to_area(raster_path, study_area):
    """Recadre un raster √† la zone d'√©tude"""
    xmin, ymin, xmax, ymax = study_area
    
    try:
        with rasterio.open(raster_path) as src:
            # Convertir coordonn√©es en indices de pixels
            row_start, col_start = src.index(xmin, ymax)  # Coin NW
            row_end, col_end = src.index(xmax, ymin)      # Coin SE
            
            # S'assurer du bon ordre
            row_start, row_end = sorted([int(row_start), int(row_end)])
            col_start, col_end = sorted([int(col_start), int(col_end)])
            
            # Limiter aux dimensions
            row_start = max(0, row_start)
            col_start = max(0, col_start)
            row_end = min(src.height - 1, row_end)
            col_end = min(src.width - 1, col_end)
            
            # Calculer la taille
            height = row_end - row_start + 1
            width = col_end - col_start + 1
            
            if width <= 0 or height <= 0:
                print(f"‚ùå Fen√™tre invalide: {width}x{height} pixels")
                return None, None
            
            # Cr√©er la fen√™tre
            window = Window(col_start, row_start, width, height)
            
            # Lire les donn√©es
            data = src.read(1, window=window)
            transform = src.window_transform(window)
            
            print(f"   ‚úÖ {data.shape[1]}√ó{data.shape[0]} pixels")
            return data, transform
            
    except Exception as e:
        print(f"‚ùå Erreur recadrage: {e}")
        return None, None

def create_building_3d_geojson(polygon, z_base, height):
    """Cr√©e une g√©om√©trie 3D pour GeoJSON"""
    try:
        coords_3d = []
        for x, y in polygon.exterior.coords:
            coords_3d.append([x, y, z_base])
        return {
            "type": "Polygon", 
            "coordinates": [coords_3d]
        }
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur g√©om√©trie 3D: {e}")
        return None

def process_vegetation_points(ndsm, dtm, mask_buildings, transform, min_height):
    """Extrait la v√©g√©tation sous forme de points"""
    veg_mask = (ndsm > min_height) & (mask_buildings == 0)
    rows, cols = np.where(veg_mask)
    
    print(f"   üå≥ Pixels v√©g√©tation: {len(rows):,}")
    
    if len(rows) == 0:
        return gpd.GeoDataFrame()
    
    # Limite pour √©viter les fichiers trop gros
    MAX_POINTS = 100000
    if len(rows) > MAX_POINTS:
        step = max(1, len(rows) // MAX_POINTS)
        rows = rows[::step]
        cols = cols[::step]
        print(f"   üîΩ √âchantillonnage: 1 point sur {step}")
    
    points_data = []
    for r, c in zip(rows, cols):
        try:
            height_val = float(ndsm[r, c])
            z_base = float(dtm[r, c])
            x, y = rasterio.transform.xy(transform, r, c, offset='center')
            
            points_data.append({
                'geometry': Point(x, y),
                'hauteur': round(height_val, 2),
                'z_base': round(z_base, 2),
                'type_veg': 'arbre'
            })
        except:
            continue
    
    if points_data:
        return gpd.GeoDataFrame(points_data, crs=TARGET_CRS)
    return gpd.GeoDataFrame()

# ------------------------------------------------------------------------------
# 4. EX√âCUTION PRINCIPALE
# ------------------------------------------------------------------------------

def main():
    print("=" * 60)
    print("GMQ710 - RECONSTRUCTION 3D")
    print("=" * 60)
    
    # Chemins complets
    dsm_path = os.path.join(BASE_PATH, DSM_FILE)
    dtm_path = os.path.join(BASE_PATH, DTM_FILE)
    osm_path = os.path.join(BASE_PATH, OSM_FILE)
    
    # V√©rification des fichiers
    for path in [dsm_path, dtm_path, osm_path]:
        if not os.path.exists(path):
            print(f"‚ùå Fichier manquant: {os.path.basename(path)}")
            return
    
    # 1. Conversion des coordonn√©es WGS84 vers UTM
    print("\nüìç CONVERSION DES COORDONN√âES...")
    print(f"   üìç Points WGS84 (lon,lat):")
    for i, (lon, lat) in enumerate(WGS84_COORDS, 1):
        print(f"     Point {i}: {lon:.6f}, {lat:.6f}")
    
    utm_coords = wgs84_to_utm(WGS84_COORDS, TARGET_CRS_EPSG)
    print(f"\n   üó∫Ô∏è  Points UTM {TARGET_CRS_EPSG} (x,y):")
    for i, (x, y) in enumerate(utm_coords, 1):
        print(f"     Point {i}: {x:.2f}, {y:.2f}")
    
    # Cr√©er la zone UTM √† partir des points
    study_area_utm = create_utm_zone_from_points(utm_coords)
    
    # 2. Obtenir les limites du raster
    print("\nüìç ANALYSE DES DONN√âES RASTER...")
    raster_bounds, raster_crs = get_raster_bounds(dsm_path)
    
    if raster_bounds is None:
        print("‚ùå Impossible de lire le DSM")
        return
    
    print(f"   üìè √âtendue totale du raster: {raster_bounds}")
    print(f"   üó∫Ô∏è  CRS: {raster_crs}")
    
    # 3. Appliquer le buffer √† la zone
    print(f"\nüó∫Ô∏è  CONFIGURATION DE LA ZONE")
    xmin, ymin, xmax, ymax = study_area_utm
    
    # Appliquer le buffer
    if BUFFER_DISTANCE > 0:
        xmin -= BUFFER_DISTANCE
        ymin -= BUFFER_DISTANCE
        xmax += BUFFER_DISTANCE
        ymax += BUFFER_DISTANCE
        print(f"   üìè Buffer appliqu√©: {BUFFER_DISTANCE}m")
    
    # Valider et ajuster la zone
    study_area = validate_and_adjust_zone((xmin, ymin, xmax, ymax), raster_bounds)
    
    width = study_area[2] - study_area[0]
    height = study_area[3] - study_area[1]
    area = width * height
    
    print(f"   üìê Zone finale UTM {TARGET_CRS_EPSG}:")
    print(f"     X: {study_area[0]:.0f} ‚Üí {study_area[2]:.0f} ({width:.0f}m)")
    print(f"     Y: {study_area[1]:.0f} ‚Üí {study_area[3]:.0f} ({height:.0f}m)")
    print(f"     Surface: {area:.0f} m¬≤ ({area/10000:.1f} ha)")
    
    if area <= 0:
        print("‚ùå Zone invalide apr√®s ajustement")
        return
    
    # Convertir la zone UTM en WGS84 pour l'affichage
    transformer_to_wgs = Transformer.from_crs(TARGET_CRS, WGS84_CRS, always_xy=True)
    lon_min, lat_min = transformer_to_wgs.transform(study_area[0], study_area[1])
    lon_max, lat_max = transformer_to_wgs.transform(study_area[2], study_area[3])
    
    print(f"\n   üåê Zone √©quivalente WGS84 (lon,lat):")
    print(f"     Longitude: {lon_min:.6f} ‚Üí {lon_max:.6f}")
    print(f"     Latitude: {lat_min:.6f} ‚Üí {lat_max:.6f}")
    
    # 4. Recadrage des rasters
    print("\nüî™ RECADRAGE DES RASTERS...")
    
    dsm, dsm_transform = crop_raster_to_area(dsm_path, study_area)
    if dsm is None:
        return
    
    dtm, dtm_transform = crop_raster_to_area(dtm_path, study_area)
    if dtm is None:
        return
    
    # Ajustement des dimensions si n√©cessaire
    if dsm.shape != dtm.shape:
        print("   ‚ö†Ô∏è Ajustement des dimensions...")
        min_height = min(dsm.shape[0], dtm.shape[0])
        min_width = min(dsm.shape[1], dtm.shape[1])
        dsm = dsm[:min_height, :min_width]
        dtm = dtm[:min_height, :min_width]
    
    # 5. Calcul du nDSM
    print("\nüìä CALCUL DES HAUTEURS...")
    ndsm = dsm - dtm
    ndsm[ndsm < 0] = 0
    
    valid_heights = ndsm[ndsm > 0]
    if len(valid_heights) > 0:
        print(f"   üìà Hauteur max: {valid_heights.max():.1f}m")
        print(f"   üìâ Hauteur moyenne: {valid_heights.mean():.1f}m")
    else:
        print("   ‚ö†Ô∏è Aucune hauteur positive d√©tect√©e")
    
    # 6. Chargement et filtrage des b√¢timents
    print("\nüè¢ TRAITEMENT DES B√ÇTIMENTS...")
    
    buildings_gdf = gpd.read_file(osm_path)
    if buildings_gdf.crs is None or str(buildings_gdf.crs) != TARGET_CRS:
        buildings_gdf = buildings_gdf.to_crs(TARGET_CRS)
    
    # Filtrer dans la zone
    zone_box = box(*study_area)
    buildings_in_zone = buildings_gdf[buildings_gdf.intersects(zone_box)].copy()
    
    print(f"   üèõÔ∏è  B√¢timents dans la zone: {len(buildings_in_zone)}/{len(buildings_gdf)}")
    
    # 7. Traitement des b√¢timents
    mask_buildings = np.zeros(dsm.shape, dtype='uint8')
    buildings_3d_data = []
    
    for idx, row in buildings_in_zone.iterrows():
        geom = row.geometry
        if geom is None or geom.is_empty:
            continue
        
        try:
            # Rasterisation pour extraction de hauteur
            mask_b = rasterize([geom], out_shape=dsm.shape, 
                             transform=dsm_transform, fill=0, 
                             default_value=1, dtype='uint8')
            mask_buildings = np.maximum(mask_buildings, mask_b)
            
            # Extraction hauteur
            h_vals = ndsm[mask_b == 1]
            if h_vals.size == 0:
                continue
            
            h_bat = float(np.percentile(h_vals[h_vals > 0], 90))
            z_base = float(dtm[mask_b == 1].min())
            
            if h_bat >= MIN_HEIGHT_BLD:
                simple_geom = geom.simplify(1.0, preserve_topology=True)
                
                # G√©rer MultiPolygon
                if simple_geom.geom_type == 'Polygon':
                    polygons = [simple_geom]
                else:
                    polygons = list(simple_geom.geoms)
                
                for poly in polygons:
                    geom_3d = create_building_3d_geojson(poly, z_base, h_bat)
                    if geom_3d:
                        buildings_3d_data.append({
                            'type': 'Feature',
                            'properties': {
                                'id': f"bat_{idx}",
                                'hauteur': round(h_bat, 2),
                                'z_base': round(z_base, 2),
                                'surface': round(poly.area, 1)
                            },
                            'geometry': geom_3d
                        })
                        
        except Exception as e:
            continue
    
    # 8. Export des b√¢timents
    print(f"\nüíæ EXPORT DES B√ÇTIMENTS...")
    
    buildings_out = os.path.join(BASE_PATH, BUILDINGS_OUTPUT)
    
    if buildings_3d_data:
        buildings_geojson = {
            "type": "FeatureCollection",
            "name": "Batiments_Sherbrooke_3D",
            "crs": { 
                "type": "name", 
                "properties": { 
                    "name": f"urn:ogc:def:crs:EPSG::{TARGET_CRS_EPSG}" 
                } 
            },
            "features": buildings_3d_data
        }
        
        with open(buildings_out, 'w', encoding='utf-8') as f:
            json.dump(buildings_geojson, f, indent=2)
        
        file_size = os.path.getsize(buildings_out) / 1024
        print(f"   ‚úÖ {len(buildings_3d_data)} b√¢timents export√©s")
        print(f"   üì¶ Taille: {file_size:.1f} KB")
    else:
        print("   ‚ö†Ô∏è Aucun b√¢timent √† exporter")
        # Cr√©er un exemple
        create_example_geojson(buildings_out, study_area)
    
    # 9. Traitement de la v√©g√©tation
    print("\nüå≥ TRAITEMENT DE LA V√âG√âTATION...")
    
    vegetation_out = os.path.join(BASE_PATH, VEGETATION_OUTPUT)
    vegetation_gdf = process_vegetation_points(ndsm, dtm, mask_buildings, dsm_transform, MIN_HEIGHT_TREE)
    
    if not vegetation_gdf.empty:
        vegetation_gdf.to_file(vegetation_out, driver='GPKG', layer='vegetation')
        file_size = os.path.getsize(vegetation_out) / (1024 * 1024)
        print(f"   ‚úÖ {len(vegetation_gdf):,} points export√©s")
        print(f"   üì¶ Taille: {file_size:.1f} MB")
    else:
        print("   ‚ÑπÔ∏è Aucune v√©g√©tation d√©tect√©e")
    
    # 10. Rapport final
    print("\n" + "=" * 60)
    print("üìã RAPPORT FINAL")
    print("=" * 60)
    print(f"üìç ZONE TRAIT√âE:")
    print(f"   ‚Ä¢ Points d'entr√©e WGS84: {len(WGS84_COORDS)} points")
    print(f"   ‚Ä¢ Zone UTM {TARGET_CRS_EPSG}: {width:.0f}m √ó {height:.0f}m")
    print(f"   ‚Ä¢ Zone WGS84 √©quivalente:")
    print(f"     Longitude: {lon_min:.6f} ‚Üí {lon_max:.6f}")
    print(f"     Latitude: {lat_min:.6f} ‚Üí {lat_max:.6f}")
    print(f"   ‚Ä¢ Surface: {area:.0f} m¬≤ ({area/10000:.1f} ha)")
    print(f"\nüìä R√âSULTATS:")
    print(f"   ‚Ä¢ üè¢ B√¢timents 3D: {len(buildings_3d_data)}")
    print(f"   ‚Ä¢ üå≥ Points v√©g√©tation: {len(vegetation_gdf)}")
    print(f"\nüíæ FICHIERS G√âN√âR√âS:")
    print(f"   ‚Ä¢ {BUILDINGS_OUTPUT}")
    print(f"   ‚Ä¢ {VEGETATION_OUTPUT}")
    print("\nüé® Pour visualiser dans QGIS:")
    print("   1. Chargez les deux fichiers")
    print("   2. Activez la vue 3D (Ctrl+3)")
    print("   3. Pour les b√¢timents: Symbologie 3D ‚Üí Extrusion")
    print("   4. Hauteur: champ 'hauteur', Base: champ 'z_base'")
    print("=" * 60)

def create_example_geojson(output_path, study_area):
    """Cr√©e un exemple minimal"""
    xmin, ymin, xmax, ymax = study_area
    center_x = (xmin + xmax) / 2
    center_y = (ymin + ymax) / 2
    
    example = {
        'type': 'Feature',
        'properties': {
            'id': 'exemple',
            'hauteur': 10.0,
            'z_base': 0.0,
            'surface': 100.0,
            'note': 'Exemple - Aucun b√¢timent OSM trouv√©'
        },
        'geometry': {
            'type': 'Polygon',
            'coordinates': [[
                [center_x - 10, center_y - 10, 0],
                [center_x + 10, center_y - 10, 0],
                [center_x + 10, center_y + 10, 0],
                [center_x - 10, center_y + 10, 0],
                [center_x - 10, center_y - 10, 0]
            ]]
        }
    }
    
    data = {
        "type": "FeatureCollection",
        "name": "Exemple_B√¢timent",
        "crs": { 
            "type": "name", 
            "properties": { 
                "name": f"urn:ogc:def:crs:EPSG::{TARGET_CRS_EPSG}" 
            } 
        },
        "features": [example]
    }
    
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2)
    print(f"   üí° Exemple cr√©√©: {output_path}")

# ------------------------------------------------------------------------------
# EX√âCUTION
# ------------------------------------------------------------------------------

if __name__ == "__main__":
    print("Instructions:")
    print("1. Modifiez WGS84_COORDS dans la section CONFIGURATION (format: longitude,latitude)")
    print("2. Ajustez BUFFER_DISTANCE si n√©cessaire")
    print("3. Lancez le script")
    print("=" * 60)
    
    # V√©rification rapide des coordonn√©es
    if WGS84_COORDS:
        print(f"‚úÖ Coordonn√©es charg√©es: {len(WGS84_COORDS)} points")
        for i, (lon, lat) in enumerate(WGS84_COORDS, 1):
            print(f"   Point {i}: {lon:.6f}, {lat:.6f}")
    else:
        print("‚ùå Aucune coordonn√©e d√©finie dans WGS84_COORDS")
        print("Veuillez ajouter des coordonn√©es au format: [[lon1, lat1], [lon2, lat2], ...]")
        exit(1)
    
    main()
    
    # G√©n√©rer un guide
    guide = """üé® GUIDE QGIS 3D

1. B√¢timents (GeoJSON):
   ‚Ä¢ Symbologie 3D ‚Üí Activer
   ‚Ä¢ Type: Extrusion simple
   ‚Ä¢ Hauteur: champ 'hauteur'
   ‚Ä¢ Base: champ 'z_base'

2. V√©g√©tation (GeoPackage):
   ‚Ä¢ Symbologie 3D ‚Üí Activer
   ‚Ä¢ Type: Mod√®le 3D simple
   ‚Ä¢ Hauteur: champ 'hauteur'
   ‚Ä¢ Mod√®le: .obj d'arbre

3. Navigation:
   ‚Ä¢ Ctrl+3 pour basculer en 3D
   ‚Ä¢ Clic-droit pour tourner
   ‚Ä¢ Molette pour zoomer

4. Coordonn√©es d'origine:
   Format utilis√©: longitude,latitude (WGS84)
   Les coordonn√©es ont √©t√© converties en UTM 19N (EPSG:26919) pour le traitement.
"""
    
    guide_path = os.path.join(BASE_PATH, "guide_qgis.txt")
    with open(guide_path, 'w', encoding='utf-8') as f:
        f.write(guide)
    print(f"\nüìñ Guide g√©n√©r√©: {guide_path}")
