#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GMQ710 - PROJET FINAL : Pipeline 3D avec zone personnalisable
Solution : B√¢timents en CityJSON + V√©g√©tation en GeoJSON (points)
Int√©gration : G√©n√©ration de points et d√©doublonnage spatial
"""

import os
import json
import numpy as np
import geopandas as gpd
import rasterio
from rasterio.features import rasterize
from rasterio.windows import Window
from shapely.geometry import Point, Polygon, box
from pyproj import Transformer
from shapely.strtree import STRtree

# ------------------------------------------------------------------------------
# 1. CONFIGURATION - √Ä MODIFIER SELON VOS BESOINS
# ------------------------------------------------------------------------------
BASE_PATH = r"C:\Users\QAREK MBENGMO\Desktop\GMQ710\TD2\Donnees sources"

# Fichiers d'entr√©e
DSM_FILE = "dsm_1m_utm19_w_22_102.tif"
DTM_FILE = "dtm_1m_utm19_w_22_102.tif"
OSM_FILE = "buildings_sherbrooke_osm.geojson"

# Fichiers de sortie
BUILDINGS_OUTPUT_CITYJSON = "batiments_3d_sherbrooke.city.json"
BUILDINGS_OUTPUT_GEOJSON = "batiments_3d_sherbrooke.geojson"  # Backup
VEGETATION_OUTPUT_GEOJSON = "vegetation_points_sherbrooke.geojson"

# Param√®tres techniques
TARGET_CRS_EPSG = 26919  # UTM 19N
TARGET_CRS = f'EPSG:{TARGET_CRS_EPSG}'
WGS84_CRS = 'EPSG:4326'  # Latitude/Longitude

MIN_HEIGHT_BLD = 3.0      # Hauteur minimale d'un b√¢timent (m)
MIN_HEIGHT_TREE = 2.5     # Hauteur minimale de v√©g√©tation (m)

# ------------------------------------------------------------------------------
# 2. D√âFINITION DE LA ZONE D'√âTUDE - MODIFIEZ ICI !
# ------------------------------------------------------------------------------
# Format : longitude,latitude (WGS84)
# Exemple : [-71.932847,45.381367],[-71.920931,45.381307],[-71.932892,45.375654],[-71.921444,45.376154]

# D√©finir vos points au format longitude,latitude
WGS84_COORDS = [
    [-71.932847, 45.381367],  # Point 1
    [-71.920931, 45.381307],  # Point 2  
    [-71.924029, 45.375547],  # Point 3
    [-71.921444, 45.376154]   # Point 4
]

BUFFER_DISTANCE = 20  # Buffer en m√®tres (recommand√©: 20)

# ------------------------------------------------------------------------------
# 3. FONCTIONS AJOUT√âES (INT√âGRATION DES BOUTS DE CODE)
# ------------------------------------------------------------------------------

def generate_close_points_latlon_gdf(n_points=1000,
                                     center_lat=45.379986,
                                     center_lon=-71.930057,
                                     spread_m=20):
    """
    G√©n√®re un GeoDataFrame de points proches autour d'une coordonn√©e lat/lon.
    Int√©gr√©e depuis le code fourni.

    - n_points  : nombre de points
    - center_lat, center_lon : centre du nuage de points
    - spread_m  : dispersion en m√®tres (√©cart-type)
    """
    # Conversion approximative m√®tres ‚Üí degr√©s
    meters_per_deg_lat = 111320
    meters_per_deg_lon = 111320 * np.cos(np.radians(center_lat))

    # Convertir l'√©cart-type en degr√©s
    spread_lat_deg = spread_m / meters_per_deg_lat
    spread_lon_deg = spread_m / meters_per_deg_lon

    # G√©n√©rer les points
    lats = np.random.normal(center_lat, spread_lat_deg, n_points)
    lons = np.random.normal(center_lon, spread_lon_deg, n_points)

    geoms = [Point(lon, lat) for lon, lat in zip(lons, lats)]

    return gpd.GeoDataFrame(geometry=geoms, crs="EPSG:4326")

def filter_close_points_spatial(gdf, min_dist_deg=0.00008):
    """
    Filtre les points trop proches en utilisant STRtree pour performance.
    Int√©gr√©e depuis le code fourni.
    
    Args:
        gdf: GeoDataFrame de points
        min_dist_deg: distance minimale en degr√©s
    
    Returns:
        GeoDataFrame filtr√©
    """
    if len(gdf) == 0:
        return gdf
    
    geoms = list(gdf.geometry)
    tree = STRtree(geoms)

    picked = []
    used = set()

    for i, p in enumerate(geoms):
        if p in used:
            continue
        picked.append(i)

        # On r√©cup√®re les indices retourn√©s par query()
        idxs = tree.query(p.buffer(min_dist_deg))

        for idx in idxs:
            neighbor = geoms[idx]   # <-- r√©cup√©rer la g√©om√©trie
            if neighbor != p and neighbor.distance(p) < min_dist_deg:
                used.add(neighbor)

    if picked:
        filtered_gdf = gdf.iloc[picked].copy().reset_index(drop=True)
        print(f"   üîç D√©doublonnage spatial: {len(filtered_gdf)}/{len(gdf)} points conserv√©s")
        return filtered_gdf
    
    return gpd.GeoDataFrame(columns=gdf.columns, crs=gdf.crs)

def export_buildings_to_cityjson(buildings_3d_data, output_path):
    """
    Exporte les b√¢timents en format CityJSON.
    
    Args:
        buildings_3d_data: liste de features GeoJSON 3D
        output_path: chemin du fichier de sortie
    """
    print(f"   üèôÔ∏è  Export CityJSON: {output_path}")
    
    # Structure CityJSON de base
    cityjson = {
        "type": "CityJSON",
        "version": "1.1",
        "metadata": {
            "referenceSystem": f"urn:ogc:def:crs:EPSG::{TARGET_CRS_EPSG}",
            "title": "B√¢timents 3D Sherbrooke",
            "creator": "GMQ710 Pipeline",
            "created": "2024",
            "transformation": {
                "scale": [1.0, 1.0, 1.0],
                "translate": [0.0, 0.0, 0.0]
            }
        },
        "CityObjects": {},
        "vertices": []
    }
    
    # Collecte tous les sommets uniques
    all_vertices = []
    vertex_index_map = {}
    vertex_counter = 0
    
    # Traitement de chaque b√¢timent
    for i, feature in enumerate(buildings_3d_data):
        building_id = f"building_{i:04d}"
        geom_3d = feature['geometry']
        props = feature['properties']
        
        if geom_3d['type'] == 'Polygon':
            # Extraire les coordonn√©es 3D
            rings = geom_3d['coordinates']
            building_boundaries = []
            
            # Pour chaque anneau (g√©n√©ralement juste l'ext√©rieur pour LOD1)
            for ring in rings:
                ring_vertices = []
                for vertex in ring:
                    # Convertir en tuple pour l'identification unique
                    vertex_tuple = tuple(vertex)
                    if vertex_tuple not in vertex_index_map:
                        vertex_index_map[vertex_tuple] = vertex_counter
                        all_vertices.append(list(vertex_tuple))
                        vertex_counter += 1
                    ring_vertices.append(vertex_index_map[vertex_tuple])
                
                # Pour un b√¢timent simple, on prend les 4 premiers sommets (carr√©)
                if len(ring_vertices) >= 4:
                    building_boundaries.append([ring_vertices[:4]])
            
            # Cr√©er l'objet CityJSON
            cityjson["CityObjects"][building_id] = {
                "type": "Building",
                "attributes": {
                    "hauteur": props.get('hauteur', 0),
                    "z_base": props.get('z_base', 0),
                    "surface": props.get('surface', 0),
                    "id": props.get('id', building_id)
                },
                "geometry": [{
                    "type": "MultiSurface",
                    "lod": 1,  # Niveau de d√©tail 1 (extrusion simple)
                    "boundaries": building_boundaries
                }]
            }
    
    # Ajouter les sommets
    cityjson["vertices"] = all_vertices
    
    # √âcrire le fichier
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(cityjson, f, indent=2)
    
    file_size = os.path.getsize(output_path) / 1024
    print(f"   ‚úÖ {len(buildings_3d_data)} b√¢timents export√©s en CityJSON")
    print(f"   üì¶ Taille: {file_size:.1f} KB")
    print(f"   üìç Fichier: {output_path}")
    
    return cityjson

def export_vegetation_to_geojson(vegetation_gdf, output_path):
    """
    Exporte la v√©g√©tation en format GeoJSON optimis√©.
    
    Args:
        vegetation_gdf: GeoDataFrame de v√©g√©tation
        output_path: chemin du fichier de sortie
    """
    print(f"   üåø Export v√©g√©tation GeoJSON: {output_path}")
    
    # Convertir en GeoJSON avec coordonn√©es 3D
    features = []
    
    for idx, row in vegetation_gdf.iterrows():
        feature = {
            "type": "Feature",
            "properties": {
                "id": f"veg_{idx:06d}",
                "hauteur": float(row.get('hauteur', 0)),
                "z_base": float(row.get('z_base', 0)),
                "type_veg": str(row.get('type_veg', 'arbre'))
            },
            "geometry": {
                "type": "Point",
                "coordinates": [
                    float(row.geometry.x),
                    float(row.geometry.y),
                    float(row.get('z_base', 0))
                ]
            }
        }
        features.append(feature)
    
    vegetation_geojson = {
        "type": "FeatureCollection",
        "name": "Vegetation_Sherbrooke_3D",
        "crs": {
            "type": "name",
            "properties": {"name": f"urn:ogc:def:crs:EPSG::{TARGET_CRS_EPSG}"}
        },
        "features": features
    }
    
    # √âcrire le fichier
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(vegetation_geojson, f, indent=2)
    
    file_size = os.path.getsize(output_path) / 1024
    print(f"   ‚úÖ {len(vegetation_gdf)} points export√©s en GeoJSON 3D")
    print(f"   üì¶ Taille: {file_size:.1f} KB")
    print(f"   üìç Fichier: {output_path}")
    
    return vegetation_geojson

def generate_supplementary_vegetation(study_area, n_points=500):
    """
    G√©n√®re des points de v√©g√©tation suppl√©mentaires quand peu de v√©g√©tation est d√©tect√©e.
    Utilise la fonction generate_close_points_latlon_gdf int√©gr√©e.
    
    Args:
        study_area: tuple (xmin, ymin, xmax, ymax) en UTM
        n_points: nombre de points √† g√©n√©rer
    
    Returns:
        GeoDataFrame de points de v√©g√©tation
    """
    print(f"   üåø G√©n√©ration de {n_points} points de v√©g√©tation suppl√©mentaires")
    
    # Convertir le centre de la zone en WGS84 pour la g√©n√©ration
    transformer_to_wgs = Transformer.from_crs(TARGET_CRS, WGS84_CRS, always_xy=True)
    
    # Calculer le centre de la zone
    x_center = (study_area[0] + study_area[2]) / 2
    y_center = (study_area[1] + study_area[3]) / 2
    
    # Convertir en WGS84
    lon_center, lat_center = transformer_to_wgs.transform(x_center, y_center)
    
    # G√©n√©rer des points avec la fonction int√©gr√©e
    points_gdf_wgs84 = generate_close_points_latlon_gdf(
        n_points=n_points,
        center_lat=lat_center,
        center_lon=lon_center,
        spread_m=min(study_area[2]-study_area[0], study_area[3]-study_area[1])/4
    )
    
    # Convertir en UTM
    points_gdf_utm = points_gdf_wgs84.to_crs(TARGET_CRS)
    
    # Ajouter des attributs r√©alistes
    points_data = []
    for idx, row in points_gdf_utm.iterrows():
        # Hauteur r√©aliste (majorit√© de buissons, quelques arbres)
        if np.random.random() < 0.3:  # 30% d'arbres
            height_val = np.random.uniform(5.0, 25.0)
            veg_type = 'arbre'
        else:  # 70% de buissons
            height_val = np.random.uniform(1.5, 4.5)
            veg_type = 'buisson'
        
        # Base al√©atoire mais r√©aliste
        z_base = np.random.uniform(200.0, 350.0)
        
        # Cr√©er un point avec attributs
        points_data.append({
            'geometry': row.geometry,
            'hauteur': round(height_val, 2),
            'z_base': round(z_base, 2),
            'type_veg': veg_type,
            'source': 'simul√©'
        })
    
    if points_data:
        veg_gdf = gpd.GeoDataFrame(points_data, crs=TARGET_CRS)
        
        # Appliquer le d√©doublonnage spatial
        # Conversion approximative: 2m ‚âà 0.000018 degr√©s
        veg_gdf = filter_close_points_spatial(veg_gdf, min_dist_deg=0.000018)
        
        return veg_gdf
    
    return gpd.GeoDataFrame()

# ------------------------------------------------------------------------------
# 4. FONCTIONS PRINCIPALES EXISTANTES
# ------------------------------------------------------------------------------

def get_raster_bounds(raster_path):
    """R√©cup√®re les limites d'un raster"""
    with rasterio.open(raster_path) as src:
        return src.bounds, src.crs

def wgs84_to_utm(coords_wgs84, target_crs_epsg=26919):
    """Convertit des coordonn√©es WGS84 (lon,lat) en UTM"""
    transformer = Transformer.from_crs(WGS84_CRS, f'EPSG:{target_crs_epsg}', always_xy=True)
    
    # Convertir chaque point
    coords_utm = []
    for lon, lat in coords_wgs84:
        x, y = transformer.transform(lon, lat)
        coords_utm.append((x, y))
    
    return coords_utm

def create_utm_zone_from_points(points_utm):
    """Cr√©e une zone UTM rectangulaire √† partir de points"""
    if not points_utm:
        return None
    
    # Extraire tous les x et y
    x_coords = [pt[0] for pt in points_utm]
    y_coords = [pt[1] for pt in points_utm]
    
    # Cr√©er une bo√Æte englobante
    xmin, xmax = min(x_coords), max(x_coords)
    ymin, ymax = min(y_coords), max(y_coords)
    
    return (xmin, ymin, xmax, ymax)

def validate_and_adjust_zone(zone_coords, raster_bounds):
    """Valide et ajuste la zone aux limites du raster"""
    xmin, ymin, xmax, ymax = zone_coords
    
    # V√©rifier l'ordre
    if xmin >= xmax:
        xmin, xmax = xmax, xmin
    if ymin >= ymax:
        ymin, ymax = ymax, ymin
    
    # Ajuster aux limites
    xmin = max(raster_bounds.left, xmin)
    ymin = max(raster_bounds.bottom, ymin)
    xmax = min(raster_bounds.right, xmax)
    ymax = min(raster_bounds.top, ymax)
    
    return (xmin, ymin, xmax, ymax)

def crop_raster_to_area(raster_path, study_area):
    """Recadre un raster √† la zone d'√©tude"""
    xmin, ymin, xmax, ymax = study_area
    
    try:
        with rasterio.open(raster_path) as src:
            # Convertir coordonn√©es en indices de pixels
            row_start, col_start = src.index(xmin, ymax)  # Coin NW
            row_end, col_end = src.index(xmax, ymin)      # Coin SE
            
            # S'assurer du bon ordre
            row_start, row_end = sorted([int(row_start), int(row_end)])
            col_start, col_end = sorted([int(col_start), int(col_end)])
            
            # Limiter aux dimensions
            row_start = max(0, row_start)
            col_start = max(0, col_start)
            row_end = min(src.height - 1, row_end)
            col_end = min(src.width - 1, col_end)
            
            # Calculer la taille
            height = row_end - row_start + 1
            width = col_end - col_start + 1
            
            if width <= 0 or height <= 0:
                print(f"‚ùå Fen√™tre invalide: {width}x{height} pixels")
                return None, None
            
            # Cr√©er la fen√™tre
            window = Window(col_start, row_start, width, height)
            
            # Lire les donn√©es
            data = src.read(1, window=window)
            transform = src.window_transform(window)
            
            print(f"   ‚úÖ {data.shape[1]}√ó{data.shape[0]} pixels")
            return data, transform
            
    except Exception as e:
        print(f"‚ùå Erreur recadrage: {e}")
        return None, None

def create_building_3d_geojson(polygon, z_base, height):
    """Cr√©e une g√©om√©trie 3D pour GeoJSON"""
    try:
        coords_3d = []
        for x, y in polygon.exterior.coords:
            coords_3d.append([x, y, z_base])
        return {
            "type": "Polygon", 
            "coordinates": [coords_3d]
        }
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur g√©om√©trie 3D: {e}")
        return None

def process_vegetation_points(ndsm, dtm, mask_buildings, transform, min_height):
    """Extrait la v√©g√©tation sous forme de points - VERSION AM√âLIOR√âE"""
    veg_mask = (ndsm > min_height) & (mask_buildings == 0)
    rows, cols = np.where(veg_mask)
    
    print(f"   üå≥ Pixels v√©g√©tation d√©tect√©s: {len(rows):,}")
    
    if len(rows) == 0:
        return gpd.GeoDataFrame()
    
    # Limite pour √©viter les fichiers trop gros
    MAX_POINTS = 50000  # R√©duit pour meilleures performances
    if len(rows) > MAX_POINTS:
        step = max(1, len(rows) // MAX_POINTS)
        rows = rows[::step]
        cols = cols[::step]
        print(f"   üîΩ √âchantillonnage: 1 point sur {step}")
    
    points_data = []
    for r, c in zip(rows, cols):
        try:
            height_val = float(ndsm[r, c])
            z_base = float(dtm[r, c])
            x, y = rasterio.transform.xy(transform, r, c, offset='center')
            
            # Classification am√©lior√©e de la v√©g√©tation
            if height_val > 8.0:
                veg_type = 'arbre_grand'
            elif height_val > 5.0:
                veg_type = 'arbre_moyen'
            elif height_val > 3.0:
                veg_type = 'arbre_petit'
            else:
                veg_type = 'buisson'
            
            points_data.append({
                'geometry': Point(x, y),
                'hauteur': round(height_val, 2),
                'z_base': round(z_base, 2),
                'type_veg': veg_type,
                'source': 'd√©tect√©'
            })
        except:
            continue
    
    if points_data:
        vegetation_gdf = gpd.GeoDataFrame(points_data, crs=TARGET_CRS)
        
        # AJOUTEZ JUSTE CES LIGNES :
        print(f"   ‚ö° R√©duction agressive des {len(vegetation_gdf):,} points...")
        
        # 1. Garder seulement les arbres > 4m
        if len(vegetation_gdf) > 0 and 'hauteur' in vegetation_gdf.columns:
            vegetation_gdf = vegetation_gdf[vegetation_gdf['hauteur'] > 4.0]
            print(f"   üìè Apr√®s filtre hauteur: {len(vegetation_gdf):,}")
        
        # 2. D√©doublonnage spatial (3m minimum)
        if len(vegetation_gdf) > 0:
            vegetation_gdf = filter_close_points_spatial(vegetation_gdf, min_dist_deg=0.000027)
        
        # 3. Limiter √† 5,000 points max
        if len(vegetation_gdf) > 5000:
            # Garder les 5,000 plus hauts
            vegetation_gdf = vegetation_gdf.nlargest(5000, 'hauteur')
            print(f"   üéØ Limit√© aux 5,000 plus hauts")
        
        print(f"   ‚úÖ Points finaux: {len(vegetation_gdf):,}")
        return vegetation_gdf
    
    return gpd.GeoDataFrame()
    
 
# ------------------------------------------------------------------------------
# 5. EX√âCUTION PRINCIPALE (AVEC INT√âGRATION)
# ------------------------------------------------------------------------------

def main():
    print("=" * 70)
    print("GMQ710 - RECONSTRUCTION 3D AVANC√âE")
    print("CityJSON (b√¢timents) + GeoJSON (v√©g√©tation) + D√©doublonnage spatial")
    print("=" * 70)
    
    # Chemins complets
    dsm_path = os.path.join(BASE_PATH, DSM_FILE)
    dtm_path = os.path.join(BASE_PATH, DTM_FILE)
    osm_path = os.path.join(BASE_PATH, OSM_FILE)
    
    # V√©rification des fichiers
    for path in [dsm_path, dtm_path, osm_path]:
        if not os.path.exists(path):
            print(f"‚ùå Fichier manquant: {os.path.basename(path)}")
            print(f"   Chemin: {path}")
            return
    
    # 1. Conversion des coordonn√©es WGS84 vers UTM
    print("\nüìç CONVERSION DES COORDONN√âES...")
    print(f"   üìç Points WGS84 (lon,lat):")
    for i, (lon, lat) in enumerate(WGS84_COORDS, 1):
        print(f"     Point {i}: {lon:.6f}, {lat:.6f}")
    
    utm_coords = wgs84_to_utm(WGS84_COORDS, TARGET_CRS_EPSG)
    print(f"\n   üó∫Ô∏è  Points UTM {TARGET_CRS_EPSG} (x,y):")
    for i, (x, y) in enumerate(utm_coords, 1):
        print(f"     Point {i}: {x:.2f}, {y:.2f}")
    
    # Cr√©er la zone UTM √† partir des points
    study_area_utm = create_utm_zone_from_points(utm_coords)
    
    # 2. Obtenir les limites du raster
    print("\nüìç ANALYSE DES DONN√âES RASTER...")
    raster_bounds, raster_crs = get_raster_bounds(dsm_path)
    
    if raster_bounds is None:
        print("‚ùå Impossible de lire le DSM")
        return
    
    print(f"   üìè √âtendue totale du raster: {raster_bounds}")
    print(f"   üó∫Ô∏è  CRS: {raster_crs}")
    
    # 3. Appliquer le buffer √† la zone
    print(f"\nüó∫Ô∏è  CONFIGURATION DE LA ZONE")
    xmin, ymin, xmax, ymax = study_area_utm
    
    # Appliquer le buffer
    if BUFFER_DISTANCE > 0:
        xmin -= BUFFER_DISTANCE
        ymin -= BUFFER_DISTANCE
        xmax += BUFFER_DISTANCE
        ymax += BUFFER_DISTANCE
        print(f"   üìè Buffer appliqu√©: {BUFFER_DISTANCE}m")
    
    # Valider et ajuster la zone
    study_area = validate_and_adjust_zone((xmin, ymin, xmax, ymax), raster_bounds)
    
    width = study_area[2] - study_area[0]
    height = study_area[3] - study_area[1]
    area = width * height
    
    print(f"   üìê Zone finale UTM {TARGET_CRS_EPSG}:")
    print(f"     X: {study_area[0]:.0f} ‚Üí {study_area[2]:.0f} ({width:.0f}m)")
    print(f"     Y: {study_area[1]:.0f} ‚Üí {study_area[3]:.0f} ({height:.0f}m)")
    print(f"     Surface: {area:.0f} m¬≤ ({area/10000:.1f} ha)")
    
    if area <= 0:
        print("‚ùå Zone invalide apr√®s ajustement")
        return
    
    # Convertir la zone UTM en WGS84 pour l'affichage
    transformer_to_wgs = Transformer.from_crs(TARGET_CRS, WGS84_CRS, always_xy=True)
    lon_min, lat_min = transformer_to_wgs.transform(study_area[0], study_area[1])
    lon_max, lat_max = transformer_to_wgs.transform(study_area[2], study_area[3])
    
    print(f"\n   üåê Zone √©quivalente WGS84 (lon,lat):")
    print(f"     Longitude: {lon_min:.6f} ‚Üí {lon_max:.6f}")
    print(f"     Latitude: {lat_min:.6f} ‚Üí {lat_max:.6f}")
    
    # 4. Recadrage des rasters
    print("\nüî™ RECADRAGE DES RASTERS...")
    
    dsm, dsm_transform = crop_raster_to_area(dsm_path, study_area)
    if dsm is None:
        return
    
    dtm, dtm_transform = crop_raster_to_area(dtm_path, study_area)
    if dtm is None:
        return
    
    # Ajustement des dimensions si n√©cessaire
    if dsm.shape != dtm.shape:
        print("   ‚ö†Ô∏è Ajustement des dimensions...")
        min_height = min(dsm.shape[0], dtm.shape[0])
        min_width = min(dsm.shape[1], dtm.shape[1])
        dsm = dsm[:min_height, :min_width]
        dtm = dtm[:min_height, :min_width]
    
    # 5. Calcul du nDSM
    print("\nüìä CALCUL DES HAUTEURS...")
    ndsm = dsm - dtm
    ndsm[ndsm < 0] = 0
    
    valid_heights = ndsm[ndsm > 0]
    if len(valid_heights) > 0:
        print(f"   üìà Hauteur max: {valid_heights.max():.1f}m")
        print(f"   üìâ Hauteur moyenne: {valid_heights.mean():.1f}m")
        print(f"   üìä Pixels avec v√©g√©tation potentielle (> {MIN_HEIGHT_TREE}m): "
              f"{np.sum(ndsm > MIN_HEIGHT_TREE):,}")
    else:
        print("   ‚ö†Ô∏è Aucune hauteur positive d√©tect√©e")
    
    # 6. Chargement et filtrage des b√¢timents
    print("\nüè¢ TRAITEMENT DES B√ÇTIMENTS...")
    
    buildings_gdf = gpd.read_file(osm_path)
    if buildings_gdf.crs is None or str(buildings_gdf.crs) != TARGET_CRS:
        buildings_gdf = buildings_gdf.to_crs(TARGET_CRS)
    
    # Filtrer dans la zone
    zone_box = box(*study_area)
    buildings_in_zone = buildings_gdf[buildings_gdf.intersects(zone_box)].copy()
    
    print(f"   üèõÔ∏è  B√¢timents dans la zone: {len(buildings_in_zone)}/{len(buildings_gdf)}")
    
    # 7. Traitement des b√¢timents
    mask_buildings = np.zeros(dsm.shape, dtype='uint8')
    buildings_3d_data = []
    
    for idx, row in buildings_in_zone.iterrows():
        geom = row.geometry
        if geom is None or geom.is_empty:
            continue
        
        try:
            # Rasterisation pour extraction de hauteur
            mask_b = rasterize([geom], out_shape=dsm.shape, 
                             transform=dsm_transform, fill=0, 
                             default_value=1, dtype='uint8')
            mask_buildings = np.maximum(mask_buildings, mask_b)
            
            # Extraction hauteur
            h_vals = ndsm[mask_b == 1]
            if h_vals.size == 0:
                continue
            
            h_bat = float(np.percentile(h_vals[h_vals > 0], 90))
            z_base = float(dtm[mask_b == 1].min())
            
            if h_bat >= MIN_HEIGHT_BLD:
                simple_geom = geom.simplify(1.0, preserve_topology=True)
                
                # G√©rer MultiPolygon
                if simple_geom.geom_type == 'Polygon':
                    polygons = [simple_geom]
                else:
                    polygons = list(simple_geom.geoms)
                
                for poly in polygons:
                    geom_3d = create_building_3d_geojson(poly, z_base, h_bat)
                    if geom_3d:
                        buildings_3d_data.append({
                            'type': 'Feature',
                            'properties': {
                                'id': f"bat_{idx}",
                                'hauteur': round(h_bat, 2),
                                'z_base': round(z_base, 2),
                                'surface': round(poly.area, 1)
                            },
                            'geometry': geom_3d
                        })
                        
        except Exception as e:
            continue
    
    # 8. Export des b√¢timents en CityJSON + GeoJSON (backup)
    print(f"\nüíæ EXPORT DES B√ÇTIMENTS...")
    
    buildings_out_cityjson = os.path.join(BASE_PATH, BUILDINGS_OUTPUT_CITYJSON)
    buildings_out_geojson = os.path.join(BASE_PATH, BUILDINGS_OUTPUT_GEOJSON)
    
    if buildings_3d_data:
        # Export principal en CityJSON
        cityjson_data = export_buildings_to_cityjson(buildings_3d_data, buildings_out_cityjson)
        
        # Export backup en GeoJSON
        buildings_geojson = {
            "type": "FeatureCollection",
            "name": "Batiments_Sherbrooke_3D",
            "crs": { 
                "type": "name", 
                "properties": { 
                    "name": f"urn:ogc:def:crs:EPSG::{TARGET_CRS_EPSG}" 
                } 
            },
            "features": buildings_3d_data
        }
        
        with open(buildings_out_geojson, 'w', encoding='utf-8') as f:
            json.dump(buildings_geojson, f, indent=2)
        
        file_size_geojson = os.path.getsize(buildings_out_geojson) / 1024
        print(f"   üìã Backup GeoJSON: {file_size_geojson:.1f} KB")
        
    else:
        print("   ‚ö†Ô∏è Aucun b√¢timent √† exporter")
        # Cr√©er un exemple
        create_example_geojson(buildings_out_geojson, study_area)
    
    # 9. Traitement de la v√©g√©tation avec d√©doublonnage
    print("\nüå≥ TRAITEMENT DE LA V√âG√âTATION AVEC D√âDOUBLONNAGE...")
    
    vegetation_out = os.path.join(BASE_PATH, VEGETATION_OUTPUT_GEOJSON)
    vegetation_gdf = process_vegetation_points(ndsm, dtm, mask_buildings, dsm_transform, MIN_HEIGHT_TREE)
    
    # INT√âGRATION : Si peu de v√©g√©tation d√©tect√©e, g√©n√©rer des points suppl√©mentaires
    if len(vegetation_gdf) < 100:
        print(f"   ‚ÑπÔ∏è  Peu de v√©g√©tation d√©tect√©e ({len(vegetation_gdf)} points)")
        print(f"   üåø Ajout de v√©g√©tation simul√©e...")
        
        supplementary_veg = generate_supplementary_vegetation(study_area, n_points=300)
        
        if not vegetation_gdf.empty and not supplementary_veg.empty:
            # Combiner v√©g√©tation d√©tect√©e et simul√©e
            combined_veg = gpd.GeoDataFrame(
                pd.concat([vegetation_gdf, supplementary_veg], ignore_index=True),
                crs=TARGET_CRS
            )
            vegetation_gdf = combined_veg
        elif not supplementary_veg.empty:
            vegetation_gdf = supplementary_veg
    
    if not vegetation_gdf.empty:
        # Export en GeoJSON 3D
        vegetation_geojson = export_vegetation_to_geojson(vegetation_gdf, vegetation_out)
        
        # Statistiques d√©taill√©es
        print(f"   üìä STATISTIQUES V√âG√âTATION:")
        print(f"      ‚Ä¢ Total points: {len(vegetation_gdf)}")
        print(f"      ‚Ä¢ Hauteur moyenne: {vegetation_gdf['hauteur'].mean():.2f}m")
        print(f"      ‚Ä¢ Hauteur max: {vegetation_gdf['hauteur'].max():.2f}m")
        
        if 'source' in vegetation_gdf.columns:
            detected = (vegetation_gdf['source'] == 'd√©tect√©').sum()
            simulated = (vegetation_gdf['source'] == 'simul√©').sum()
            print(f"      ‚Ä¢ Source: {detected} d√©tect√©s, {simulated} simul√©s")
        
        # Distribution par type
        if 'type_veg' in vegetation_gdf.columns:
            print(f"      ‚Ä¢ Distribution par type:")
            type_counts = vegetation_gdf['type_veg'].value_counts()
            for veg_type, count in type_counts.items():
                percentage = (count / len(vegetation_gdf)) * 100
                print(f"        {veg_type}: {count} points ({percentage:.1f}%)")
    else:
        print("   ‚ÑπÔ∏è Aucune v√©g√©tation d√©tect√©e ou g√©n√©r√©e")
    
    # 10. Rapport final am√©lior√©
    print("\n" + "=" * 70)
    print("üìã RAPPORT FINAL - INT√âGRATION COMPL√àTE")
    print("=" * 70)
    
    print(f"üìç ZONE TRAIT√âE:")
    print(f"   ‚Ä¢ Surface: {area:.0f} m¬≤ ({area/10000:.1f} ha)")
    print(f"   ‚Ä¢ Dimensions: {width:.0f}m √ó {height:.0f}m")
    
    print(f"\nüìä R√âSULTATS:")
    print(f"   ‚Ä¢ üè¢ B√¢timents 3D: {len(buildings_3d_data)}")
    print(f"   ‚Ä¢ üå≥ Points v√©g√©tation: {len(vegetation_gdf) if not vegetation_gdf.empty else 0}")
    
    if not vegetation_gdf.empty:
        avg_height = vegetation_gdf['hauteur'].mean()
        max_height = vegetation_gdf['hauteur'].max()
        print(f"      ‚Üí Hauteur moyenne: {avg_height:.1f}m, Max: {max_height:.1f}m")
        
        # Calcul de la densit√©
        points_per_ha = len(vegetation_gdf) / (area / 10000) if area > 0 else 0
        print(f"      ‚Üí Densit√©: {points_per_ha:.1f} points/ha")
    
    print(f"\nüíæ FICHIERS G√âN√âR√âS:")
    print(f"   ‚Ä¢ {BUILDINGS_OUTPUT_CITYJSON} (format CityJSON - recommand√©)")
    print(f"   ‚Ä¢ {BUILDINGS_OUTPUT_GEOJSON} (format GeoJSON - backup)")
    print(f"   ‚Ä¢ {VEGETATION_OUTPUT_GEOJSON} (format GeoJSON 3D)")
    
    print(f"\nüîß FONCTIONNALIT√âS INT√âGR√âES:")
    print(f"   ‚Ä¢ ‚úÖ G√©n√©ration de points al√©atoires (pour tests)")
    print(f"   ‚Ä¢ ‚úÖ D√©doublonnage spatial avec STRtree")
    print(f"   ‚Ä¢ ‚úÖ Export CityJSON pour b√¢timents")
    print(f"   ‚Ä¢ ‚úÖ Export GeoJSON 3D pour v√©g√©tation")
    print(f"   ‚Ä¢ ‚úÖ Classification am√©lior√©e de la v√©g√©tation")
    
    print("\nüé® POUR VISUALISER:")
    print("   1. CityJSON: Utilisez le plugin CityJSON Loader dans QGIS")
    print("   2. GeoJSON: Chargement natif dans QGIS")
    print("   3. Vue 3D: Ctrl+3, extrusion par hauteur (champ 'hauteur')")
    print("=" * 70)
    
    return {
        'success': True,
        'buildings_count': len(buildings_3d_data),
        'vegetation_count': len(vegetation_gdf) if not vegetation_gdf.empty else 0,
        'cityjson_file': BUILDINGS_OUTPUT_CITYJSON,
        'geojson_file': VEGETATION_OUTPUT_GEOJSON
    }

def create_example_geojson(output_path, study_area):
    """Cr√©e un exemple minimal"""
    xmin, ymin, xmax, ymax = study_area
    center_x = (xmin + xmax) / 2
    center_y = (ymin + ymax) / 2
    
    example = {
        'type': 'Feature',
        'properties': {
            'id': 'exemple',
            'hauteur': 10.0,
            'z_base': 0.0,
            'surface': 100.0,
            'note': 'Exemple - Aucun b√¢timent OSM trouv√©'
        },
        'geometry': {
            'type': 'Polygon',
            'coordinates': [[
                [center_x - 10, center_y - 10, 0],
                [center_x + 10, center_y - 10, 0],
                [center_x + 10, center_y + 10, 0],
                [center_x - 10, center_y + 10, 0],
                [center_x - 10, center_y - 10, 0]
            ]]
        }
    }
    
    data = {
        "type": "FeatureCollection",
        "name": "Exemple_B√¢timent",
        "crs": { 
            "type": "name", 
            "properties": { 
                "name": f"urn:ogc:def:crs:EPSG::{TARGET_CRS_EPSG}" 
            } 
        },
        "features": [example]
    }
    
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2)
    print(f"   üí° Exemple cr√©√©: {output_path}")

# ------------------------------------------------------------------------------
# EX√âCUTION
# ------------------------------------------------------------------------------

if __name__ == "__main__":
    print("Instructions:")
    print("1. Modifiez WGS84_COORDS dans la section CONFIGURATION")
    print("2. Ajustez BUFFER_DISTANCE si n√©cessaire")
    print("3. Le script g√©n√®re CityJSON (b√¢timents) + GeoJSON (v√©g√©tation)")
    print("=" * 70)
    
    # V√©rification rapide des coordonn√©es
    if WGS84_COORDS:
        print(f"‚úÖ Coordonn√©es charg√©es: {len(WGS84_COORDS)} points")
        for i, (lon, lat) in enumerate(WGS84_COORDS, 1):
            print(f"   Point {i}: {lon:.6f}, {lat:.6f}")
    else:
        print("‚ùå Aucune coordonn√©e d√©finie dans WGS84_COORDS")
        print("Veuillez ajouter des coordonn√©es au format: [[lon1, lat1], [lon2, lat2], ...]")
        exit(1)
    
    try:
        import pandas as pd
        print("‚úÖ pandas import√© avec succ√®s")
    except ImportError:
        print("‚ö†Ô∏è  pandas n'est pas install√©. Installation recommand√©e.")
        print("   pip install pandas")
        # D√©finir un substitut simple si pandas n'est pas disponible
        class SimpleConcat:
            @staticmethod
            def concat(dfs, ignore_index=True):
                # Impl√©mentation simplifi√©e
                return dfs[0] if len(dfs) == 1 else None
        pd = type('pd', (), {'concat': SimpleConcat.concat})()
    
    main()
    
    # G√©n√©rer un guide am√©lior√©
    guide = """üé® GUIDE UTILISATION AVANC√âE

FORMATS DE SORTIE:
1. CityJSON (.city.json) - B√¢timents 3D
   ‚Ä¢ Format standard OGC pour villes 3D
   ‚Ä¢ Structure optimis√©e pour le web
   ‚Ä¢ Compatible avec: Cesium, Three.js, FME
   ‚Ä¢ Visualisation: Plugin CityJSON Loader dans QGIS

2. GeoJSON (.geojson) - V√©g√©tation 3D
   ‚Ä¢ Format universel et l√©ger
   ‚Ä¢ Points avec coordonn√©es 3D (x, y, z)
   ‚Ä¢ Attributs: hauteur, type_veg, source
   ‚Ä¢ Compatible avec: QGIS, ArcGIS, Mapbox

FONCTIONNALIT√âS INT√âGR√âES:
‚Ä¢ G√©n√©ration de points: Cr√©ation de donn√©es de test
‚Ä¢ D√©doublonnage spatial: √âlimination des points trop proches
‚Ä¢ Classification: Arbres (grand/moyen/petit) et buissons
‚Ä¢ Compl√©mentation: Points simul√©s si faible d√©tection

VISUALISATION QGIS:
1. B√¢timents (CityJSON):
   - Installer le plugin "CityJSON Loader"
   - Charger le fichier .city.json
   - Vue 3D: Symbologie ‚Üí Hauteur par extrusion

2. V√©g√©tation (GeoJSON):
   - Chargement natif
   - Symbologie 3D: Points ‚Üí Mod√®les 3D
   - Hauteur: Utiliser le champ 'hauteur'

PARAM√àTRES AJUSTABLES:
‚Ä¢ WGS84_COORDS: Coordonn√©es de la zone
‚Ä¢ BUFFER_DISTANCE: Buffer autour de la zone
‚Ä¢ MIN_HEIGHT_BLD/TREE: Seuils de hauteur

TESTS DE FONCTIONNALIT√â:
Le code int√®gre des fonctions de g√©n√©ration de points
pour tester le pipeline sans donn√©es r√©elles.
"""
    
    guide_path = os.path.join(BASE_PATH, "guide_avance.txt")
    with open(guide_path, 'w', encoding='utf-8') as f:
        f.write(guide)
    print(f"\nüìñ Guide avanc√© g√©n√©r√©: {guide_path}")
